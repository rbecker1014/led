<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>LED Arch Calculator</title>
  <style>
    :root {
      --bg: #0a0e14;
      --card: #111826;
      --border: rgba(255,255,255,0.08);
      --text: #e7eef8;
      --muted: #8b9cb3;
      --accent: #3b82f6;
      --accent-dim: rgba(59,130,246,0.15);
      --success: #10b981;
      --warn-bg: rgba(251,146,60,0.12);
      --warn-border: rgba(251,146,60,0.25);
      --warn-text: #fb923c;
      --tube-a: rgba(96,165,250,0.35);
      --tube-b: rgba(52,211,153,0.35);
      --join: #f472b6;
      --ground: rgba(255,255,255,0.08);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 20px;
      min-height: 100vh;
    }
    @media (max-width: 900px) {
      .container { grid-template-columns: 1fr; }
    }
    .panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
    }
    h1 {
      font-size: 1.25rem;
      font-weight: 600;
      margin: 0 0 4px;
    }
    .subtitle {
      color: var(--muted);
      font-size: 0.8rem;
      margin: 0 0 20px;
    }
    .section {
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--border);
    }
    .section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
    .section-title {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
      margin: 0 0 12px;
    }
    label {
      display: block;
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .field { margin-bottom: 14px; }
    .field:last-child { margin-bottom: 0; }
    input[type="number"], input[type="text"], select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: rgba(0,0,0,0.25);
      color: var(--text);
      font-size: 0.9rem;
      transition: border-color 0.2s;
    }
    input:focus, select:focus {
      outline: none;
      border-color: var(--accent);
    }
    input:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }

    /* Slider styling */
    .slider-field {
      margin-bottom: 14px;
    }
    .slider-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .slider-row input[type="range"] {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: rgba(255,255,255,0.1);
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
    }
    .slider-row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid rgba(255,255,255,0.2);
    }
    .slider-row input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid rgba(255,255,255,0.2);
    }
    .slider-row input[type="number"] {
      width: 70px;
      flex-shrink: 0;
    }

    /* Toggle switch */
    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 0;
    }
    .toggle-label {
      font-size: 0.85rem;
      color: var(--text);
    }
    .toggle {
      position: relative;
      width: 44px;
      height: 24px;
    }
    .toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      inset: 0;
      background: rgba(255,255,255,0.1);
      border-radius: 24px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .toggle-slider::before {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      left: 3px;
      top: 3px;
      background: white;
      border-radius: 50%;
      transition: transform 0.2s;
    }
    .toggle input:checked + .toggle-slider {
      background: var(--accent);
    }
    .toggle input:checked + .toggle-slider::before {
      transform: translateX(20px);
    }

    /* Results grid */
    .results-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .result-item {
      background: rgba(0,0,0,0.2);
      border-radius: 10px;
      padding: 12px;
    }
    .result-label {
      font-size: 0.7rem;
      color: var(--muted);
      margin-bottom: 4px;
    }
    .result-value {
      font-size: 1rem;
      font-weight: 600;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
    }
    .result-value.success { color: var(--success); }
    .result-value.warn { color: var(--warn-text); }

    /* Warning box */
    .warning {
      margin-top: 14px;
      padding: 12px;
      background: var(--warn-bg);
      border: 1px solid var(--warn-border);
      border-radius: 10px;
      font-size: 0.8rem;
      color: rgba(255,255,255,0.85);
      display: none;
    }
    .warning.visible { display: block; }
    .warning strong { color: var(--warn-text); }

    /* Note box */
    .note {
      margin-top: 12px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.04);
      border-radius: 10px;
      font-size: 0.75rem;
      color: var(--muted);
      line-height: 1.5;
    }

    /* SVG container */
    .viz-panel {
      display: flex;
      flex-direction: column;
    }
    .viz-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .viz-title {
      font-size: 0.9rem;
      font-weight: 600;
    }
    .viz-controls {
      display: flex;
      gap: 8px;
    }
    .viz-btn {
      padding: 6px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: transparent;
      color: var(--muted);
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .viz-btn:hover, .viz-btn.active {
      background: var(--accent-dim);
      border-color: var(--accent);
      color: var(--text);
    }
    svg {
      flex: 1;
      width: 100%;
      min-height: 500px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02) 0%, rgba(0,0,0,0.1) 100%);
      border-radius: 14px;
      border: 1px solid var(--border);
    }

    /* Legend */
    .legend {
      display: flex;
      gap: 16px;
      margin-top: 12px;
      flex-wrap: wrap;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75rem;
      color: var(--muted);
    }
    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    .legend-line {
      width: 20px;
      height: 3px;
      border-radius: 2px;
    }
  </style>
</head>
<body>
<div class="container">
  <!-- Control Panel -->
  <div class="panel">
    <h1>LED Arch Calculator</h1>
    <p class="subtitle">Design a flexible PEX tubing LED arch with pivoting base anchors</p>

    <!-- INPUTS Section -->
    <div class="section">
      <div class="section-title">ðŸ“¥ Inputs</div>
      <div class="slider-field">
        <label for="width">Base width (ft)</label>
        <div class="slider-row">
          <input type="range" id="widthSlider" value="10" min="3" max="20" step="0.5">
          <input type="number" id="width" value="10" min="3" max="20" step="0.5">
        </div>
      </div>
      <div class="slider-field">
        <label for="archLength">Arch length (ft)</label>
        <div class="slider-row">
          <input type="range" id="archLengthSlider" value="16" min="4" max="40" step="0.5">
          <input type="number" id="archLength" value="16" min="4" max="40" step="0.5">
        </div>
      </div>
      <div class="note" style="margin-top: 14px;">
        <strong>How it works:</strong> Set the distance between the base anchors and the total tubing length. The arch shape, height, and base angle are computed automatically. Shorter tubing = shallower angle.
      </div>
    </div>

    <!-- Tubing & Cuts -->
    <div class="section">
      <div class="section-title">Tubing & Cuts</div>
      <div class="row">
        <div class="field">
          <label for="stickLength">PEX stick length (ft)</label>
          <input type="number" id="stickLength" value="10" min="1" max="20" step="0.5">
        </div>
        <div class="field">
          <label for="cutStrategy">Cut strategy</label>
          <select id="cutStrategy">
            <option value="equal">Equal cuts (join at midpoint)</option>
            <option value="offset">Full + cut stick (offset join)</option>
          </select>
        </div>
      </div>
    </div>

    <!-- LED Configuration -->
    <div class="section">
      <div class="section-title">LED Strip Configuration</div>
      <div class="row">
        <div class="field">
          <label for="ledLength">Strip length (ft)</label>
          <input type="number" id="ledLength" value="16.4" min="1" max="100" step="0.1">
        </div>
        <div class="field">
          <label for="ledCount">Number of LEDs</label>
          <input type="number" id="ledCount" value="300" min="10" max="1000" step="1">
        </div>
      </div>
      <div class="toggle-row" style="margin-top: 8px;">
        <span class="toggle-label">Blinking mode</span>
        <label class="toggle">
          <input type="checkbox" id="blinkMode">
          <span class="toggle-slider"></span>
        </label>
      </div>
    </div>

    <!-- DERIVED Section -->
    <div class="section">
      <div class="section-title">ðŸ“¤ Derived Values</div>
      <div class="results-grid">
        <div class="result-item">
          <div class="result-label">Apex height</div>
          <div class="result-value" id="resultHeight">â€”</div>
        </div>
        <div class="result-item">
          <div class="result-label">Base angle</div>
          <div class="result-value" id="resultAngle">â€”</div>
        </div>
        <div class="result-item">
          <div class="result-label">Curvature ratio</div>
          <div class="result-value" id="resultCurvature">â€”</div>
        </div>
        <div class="result-item">
          <div class="result-label">LED fit</div>
          <div class="result-value" id="resultLedFit">â€”</div>
        </div>
      </div>
      <div class="results-grid" style="margin-top: 12px;">
        <div class="result-item">
          <div class="result-label">Cut lengths</div>
          <div class="result-value" id="resultCuts">â€”</div>
        </div>
        <div class="result-item">
          <div class="result-label">Material waste</div>
          <div class="result-value" id="resultWaste">â€”</div>
        </div>
      </div>
      <div class="warning" id="warning"></div>
    </div>
  </div>

  <!-- Visualization Panel -->
  <div class="panel viz-panel">
    <div class="viz-header">
      <span class="viz-title">Arch Visualization</span>
      <div class="viz-controls">
        <button class="viz-btn active" id="btnHeatmap">Heat Map</button>
        <button class="viz-btn" id="btnLeds">Show LEDs</button>
        <button class="viz-btn" id="btnJoins">Show Joins</button>
      </div>
    </div>
    <svg id="svg" viewBox="0 0 800 500" preserveAspectRatio="xMidYMid meet">
      <defs>
        <linearGradient id="groundGrad" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%" stop-color="transparent"/>
          <stop offset="50%" stop-color="rgba(255,255,255,0.1)"/>
          <stop offset="100%" stop-color="transparent"/>
        </linearGradient>
      </defs>
      <!-- Ground line -->
      <line id="ground" x1="50" y1="450" x2="750" y2="450" stroke="url(#groundGrad)" stroke-width="2"/>
      <!-- Arch group -->
      <g id="archGroup"></g>
    </svg>
    <div class="legend">
      <div class="legend-item">
        <div class="legend-line" style="background: linear-gradient(90deg, #22c55e, #eab308, #ef4444);"></div>
        <span>Curvature (low â†’ high)</span>
      </div>
      <div class="legend-item">
        <div class="legend-dot" style="background: #f472b6;"></div>
        <span>Join point</span>
      </div>
      <div class="legend-item">
        <div class="legend-line" style="background: #fbbf24; height: 2px;"></div>
        <span>Base angle</span>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  'use strict';

  // DOM Elements
  const $ = id => document.getElementById(id);
  const els = {
    width: $('width'),
    widthSlider: $('widthSlider'),
    archLength: $('archLength'),
    archLengthSlider: $('archLengthSlider'),
    stickLength: $('stickLength'),
    cutStrategy: $('cutStrategy'),
    ledLength: $('ledLength'),
    ledCount: $('ledCount'),
    blinkMode: $('blinkMode'),
    warning: $('warning'),
    svg: $('svg'),
    archGroup: $('archGroup'),
    resultHeight: $('resultHeight'),
    resultAngle: $('resultAngle'),
    resultCurvature: $('resultCurvature'),
    resultLedFit: $('resultLedFit'),
    resultCuts: $('resultCuts'),
    resultWaste: $('resultWaste'),
    btnHeatmap: $('btnHeatmap'),
    btnLeds: $('btnLeds'),
    btnJoins: $('btnJoins')
  };

  // State
  let showHeatmap = true;
  let showLeds = false;
  let showJoins = false;
  let blinkState = true;
  let blinkInterval = null;

  // Constants
  const SVG_WIDTH = 800;
  const SVG_HEIGHT = 500;
  const MARGIN = 60;
  const GROUND_Y = 450;
  const CURVE_SAMPLES = 200;

  // Rainbow colors for LEDs
  const rainbowColors = [
    '#ff0000', '#ff4500', '#ff8c00', '#ffd700', '#adff2f',
    '#00ff00', '#00fa9a', '#00ffff', '#1e90ff', '#4169e1',
    '#8a2be2', '#ff00ff', '#ff1493', '#ff69b4'
  ];

  /**
   * Generate cubic Bezier curve with hinged/pivoting ends
   *
   * Physics model:
   * - Flexible tube pinned at both ends with pivot anchors
   * - Ends can rotate inward at angle theta from horizontal
   * - Shorter arch = shallower angle, longer arch = steeper angle
   *
   * @param {number} W - Width at ground (distance between anchors)
   * @param {number} theta - Base angle in radians (from horizontal)
   * @param {number} d - Control point distance from anchor
   */
  function generateBezierCurve(W, theta, d) {
    const points = [];

    // Anchor points at ground level
    const P0 = { x: -W / 2, y: 0 };
    const P3 = { x: W / 2, y: 0 };

    // Control points - angled inward from anchors
    // Left control point: rises at angle theta
    const P1 = {
      x: P0.x + d * Math.cos(theta),
      y: P0.y + d * Math.sin(theta)
    };
    // Right control point: mirrors left (rises at angle theta from right)
    const P2 = {
      x: P3.x - d * Math.cos(theta),
      y: P3.y + d * Math.sin(theta)
    };

    for (let i = 0; i <= CURVE_SAMPLES; i++) {
      const t = i / CURVE_SAMPLES;
      const mt = 1 - t;
      const mt2 = mt * mt;
      const mt3 = mt2 * mt;
      const t2 = t * t;
      const t3 = t2 * t;

      points.push({
        x: mt3 * P0.x + 3 * mt2 * t * P1.x + 3 * mt * t2 * P2.x + t3 * P3.x,
        y: mt3 * P0.y + 3 * mt2 * t * P1.y + 3 * mt * t2 * P2.y + t3 * P3.y,
        t
      });
    }

    return { points, P0, P1, P2, P3, theta, d };
  }

  /**
   * Calculate arc length of curve using numerical integration
   */
  function calculateArcLength(points) {
    let length = 0;
    for (let i = 1; i < points.length; i++) {
      const dx = points[i].x - points[i - 1].x;
      const dy = points[i].y - points[i - 1].y;
      length += Math.sqrt(dx * dx + dy * dy);
    }
    return length;
  }

  /**
   * Calculate curvature at each point using Menger curvature formula
   */
  function calculateCurvature(points) {
    const curvatures = [0]; // First point

    for (let i = 1; i < points.length - 1; i++) {
      const p0 = points[i - 1];
      const p1 = points[i];
      const p2 = points[i + 1];

      // Side lengths
      const a = Math.hypot(p1.x - p0.x, p1.y - p0.y);
      const b = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      const c = Math.hypot(p2.x - p0.x, p2.y - p0.y);

      // Triangle area using cross product
      const area = Math.abs((p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x)) / 2;

      // Menger curvature: k = 4 * area / (a * b * c)
      const denom = a * b * c;
      curvatures.push(denom > 0.0001 ? (4 * area) / denom : 0);
    }

    curvatures.push(0); // Last point
    return curvatures;
  }

  /**
   * Calculate curvature concentration metric (q95/q50)
   */
  function calculateConcentration(curvatures) {
    const sorted = [...curvatures].filter(k => k > 0).sort((a, b) => a - b);
    if (sorted.length < 10) return 1;

    const q50 = sorted[Math.floor(sorted.length * 0.5)];
    const q95 = sorted[Math.floor(sorted.length * 0.95)];

    return q50 > 0 ? q95 / q50 : 1;
  }

  /**
   * Solve for the arch shape given width and target arc length.
   *
   * The angle theta is derived from the length-to-width ratio:
   * - Short arch (L close to W) = shallow angle
   * - Long arch (L much greater than W) = steep angle
   *
   * The control point distance d is then computed to achieve the exact arc length.
   * A constraint prevents loops: control points must not cross the center.
   */
  function solveForShape(W, targetLength) {
    // Clamp length to valid range
    const minLen = W * 1.02;
    const maxLen = W * 2.2;
    const L = Math.max(minLen, Math.min(maxLen, targetLength));

    // Compute angle from length ratio
    // As L/W increases, angle increases
    const ratio = (L - minLen) / (maxLen - minLen);

    // Angle ranges from ~20Â° (shallow) to ~80Â° (steep)
    const thetaMin = 20 * Math.PI / 180;
    const thetaMax = 80 * Math.PI / 180;
    const theta = thetaMin + ratio * (thetaMax - thetaMin);

    // Maximum d to prevent loops: P1.x must stay < 0
    // P1.x = -W/2 + d*cos(theta) < 0
    // d < W / (2*cos(theta))
    const maxD = (W / (2 * Math.cos(theta))) * 0.95;

    // Binary search for d that gives target arc length
    let lo = 0.1;
    let hi = Math.min(maxD, W * 2);

    for (let iter = 0; iter < 50; iter++) {
      const mid = (lo + hi) / 2;
      const { points } = generateBezierCurve(W, theta, mid);
      const len = calculateArcLength(points);

      if (Math.abs(len - L) < 0.001) break;

      if (len < L) {
        lo = mid;  // Need larger d for longer arc
      } else {
        hi = mid;  // Need smaller d for shorter arc
      }
    }

    const d = (lo + hi) / 2;
    return { theta, d };
  }

  /**
   * Get the apex height from curve points
   */
  function getApexHeight(points) {
    return Math.max(...points.map(p => p.y));
  }

  /**
   * Get curvature color (green â†’ yellow â†’ red)
   */
  function getCurvatureColor(k, maxK) {
    const ratio = Math.min(k / maxK, 1);

    if (ratio < 0.5) {
      // Green to Yellow
      const t = ratio * 2;
      const r = Math.round(34 + t * (234 - 34));
      const g = Math.round(197 + t * (179 - 197));
      const b = Math.round(94 + t * (8 - 94));
      return `rgb(${r},${g},${b})`;
    } else {
      // Yellow to Red
      const t = (ratio - 0.5) * 2;
      const r = Math.round(234 + t * (239 - 234));
      const g = Math.round(179 - t * 179);
      const b = Math.round(8 - t * 8);
      return `rgb(${r},${g},${b})`;
    }
  }

  /**
   * Transform coordinates to SVG space
   */
  function toSVG(x, y, scale, centerX) {
    return {
      x: centerX + x * scale,
      y: GROUND_Y - y * scale
    };
  }

  /**
   * Calculate cut information
   */
  function calculateCuts(tubeLength, stickLength, strategy) {
    const sticksNeeded = Math.ceil(tubeLength / stickLength);
    const totalMaterial = sticksNeeded * stickLength;
    const waste = totalMaterial - tubeLength;

    let cuts, joinPosition;

    if (strategy === 'equal') {
      // Equal cuts on both sides, join at midpoint
      const cutLen = tubeLength / 2;
      cuts = `2 Ã— ${cutLen.toFixed(2)} ft`;
      joinPosition = 0.5;
    } else {
      // One full stick + cut stick
      if (tubeLength <= stickLength) {
        cuts = `1 Ã— ${tubeLength.toFixed(2)} ft`;
        joinPosition = null;
      } else {
        const remainder = tubeLength - stickLength;
        cuts = `${stickLength} ft + ${remainder.toFixed(2)} ft`;
        joinPosition = stickLength / tubeLength;
      }
    }

    return { cuts, waste, sticksNeeded, joinPosition };
  }

  /**
   * Calculate LED fit information
   */
  function calculateLedFit(tubeLength, ledLength) {
    if (ledLength >= tubeLength) {
      const trim = ledLength - tubeLength;
      return {
        status: trim > 0 ? 'trim' : 'exact',
        message: trim > 0 ? `Trim ${trim.toFixed(2)} ft` : 'Perfect fit',
        coverage: 1,
        gap: 0,
        trim
      };
    } else {
      const gap = (tubeLength - ledLength) / 2;
      return {
        status: 'gap',
        message: `Gap ${gap.toFixed(2)} ft each end`,
        coverage: ledLength / tubeLength,
        gap,
        trim: 0
      };
    }
  }

  /**
   * Main render function
   */
  function render() {
    const W = parseFloat(els.width.value) || 10;
    const L = parseFloat(els.archLength.value) || 16;
    const stickLen = parseFloat(els.stickLength.value) || 10;
    const cutStrategy = els.cutStrategy.value;
    const ledLen = parseFloat(els.ledLength.value) || 16.4;
    const ledNum = parseInt(els.ledCount.value) || 300;

    // Validate: arch length must be greater than base width
    const minLength = W * 1.02;
    const maxLength = W * 2.2;  // Reasonable maximum for smooth arch
    const clampedL = Math.max(minLength, Math.min(maxLength, L));

    // Solve for the shape (theta and d) that gives the target arc length
    const { theta, d } = solveForShape(W, clampedL);
    const curve = generateBezierCurve(W, theta, d);
    const length = calculateArcLength(curve.points);
    const height = getApexHeight(curve.points);
    const baseAngleRad = theta;
    const baseAngleDeg = baseAngleRad * (180 / Math.PI);

    const curvatures = calculateCurvature(curve.points);
    const concentration = calculateConcentration(curvatures);
    const maxCurvature = Math.max(...curvatures);
    const cutInfo = calculateCuts(length, stickLen, cutStrategy);
    const ledFit = calculateLedFit(length, ledLen);

    // Update results
    els.resultHeight.textContent = `${height.toFixed(2)} ft`;
    els.resultAngle.textContent = `${baseAngleDeg.toFixed(1)}Â°`;
    els.resultCurvature.textContent = `${concentration.toFixed(2)}Ã—`;
    els.resultCurvature.className = 'result-value' + (concentration > 1.5 ? ' warn' : ' success');

    els.resultLedFit.textContent = ledFit.message;
    els.resultLedFit.className = 'result-value' + (ledFit.status === 'exact' ? ' success' : '');

    els.resultCuts.textContent = cutInfo.cuts;
    els.resultWaste.textContent = `${cutInfo.waste.toFixed(2)} ft`;
    els.resultWaste.className = 'result-value' + (cutInfo.waste > 2 ? ' warn' : '');

    // Warning for invalid length
    if (L < minLength) {
      els.warning.innerHTML = `<strong>Warning:</strong> Arch length must be greater than base width. Min: ${minLength.toFixed(1)} ft.`;
      els.warning.classList.add('visible');
    } else if (L > maxLength) {
      els.warning.innerHTML = `<strong>Warning:</strong> Arch length too long for smooth curve. Max: ${maxLength.toFixed(1)} ft.`;
      els.warning.classList.add('visible');
    } else {
      els.warning.classList.remove('visible');
    }

    // Calculate SVG scale
    const maxDim = Math.max(W, height) * 1.3;
    const scale = (SVG_WIDTH - MARGIN * 2) / maxDim;
    const centerX = SVG_WIDTH / 2;

    // Clear previous rendering
    els.archGroup.innerHTML = '';

    // Render tube segments with curvature heat map
    if (showHeatmap) {
      for (let i = 0; i < curve.points.length - 1; i++) {
        const p1 = toSVG(curve.points[i].x, curve.points[i].y, scale, centerX);
        const p2 = toSVG(curve.points[i + 1].x, curve.points[i + 1].y, scale, centerX);
        const color = getCurvatureColor(curvatures[i], maxCurvature);

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', p1.x);
        line.setAttribute('y1', p1.y);
        line.setAttribute('x2', p2.x);
        line.setAttribute('y2', p2.y);
        line.setAttribute('stroke', color);
        line.setAttribute('stroke-width', '14');
        line.setAttribute('stroke-linecap', 'round');
        line.setAttribute('opacity', '0.7');
        els.archGroup.appendChild(line);
      }
    } else {
      // Simple tube rendering
      const pathData = curve.points.map((p, i) => {
        const sp = toSVG(p.x, p.y, scale, centerX);
        return (i === 0 ? 'M' : 'L') + sp.x.toFixed(1) + ',' + sp.y.toFixed(1);
      }).join(' ');

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', pathData);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', 'rgba(96,165,250,0.5)');
      path.setAttribute('stroke-width', '14');
      path.setAttribute('stroke-linecap', 'round');
      els.archGroup.appendChild(path);
    }

    // Render join point
    if (showJoins && cutInfo.joinPosition !== null) {
      const joinIndex = Math.floor(cutInfo.joinPosition * (curve.points.length - 1));
      const jp = curve.points[joinIndex];
      const sjp = toSVG(jp.x, jp.y, scale, centerX);

      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', sjp.x);
      circle.setAttribute('cy', sjp.y);
      circle.setAttribute('r', '10');
      circle.setAttribute('fill', '#f472b6');
      circle.setAttribute('stroke', 'white');
      circle.setAttribute('stroke-width', '2');
      els.archGroup.appendChild(circle);

      // Join label
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', sjp.x + 15);
      text.setAttribute('y', sjp.y - 10);
      text.setAttribute('fill', '#f472b6');
      text.setAttribute('font-size', '12');
      text.setAttribute('font-family', 'system-ui');
      text.textContent = 'Join';
      els.archGroup.appendChild(text);
    }

    // Render LEDs
    if (showLeds) {
      // Calculate LED positions along curve
      const totalCurveLen = length;
      const ledSpacing = ledLen / ledNum;

      // Calculate cumulative distances
      const distances = [0];
      for (let i = 1; i < curve.points.length; i++) {
        const dx = curve.points[i].x - curve.points[i - 1].x;
        const dy = curve.points[i].y - curve.points[i - 1].y;
        distances.push(distances[i - 1] + Math.sqrt(dx * dx + dy * dy));
      }

      // LED strip position
      const startDist = ledFit.gap;
      const endDist = startDist + ledLen;

      // Render each LED
      for (let i = 0; i < ledNum; i++) {
        const ledDist = startDist + (i + 0.5) * ledSpacing;
        if (ledDist > totalCurveLen) break;

        // Find position on curve
        let segIndex = 0;
        for (let j = 1; j < distances.length; j++) {
          if (distances[j] >= ledDist) {
            segIndex = j - 1;
            break;
          }
        }

        // Interpolate position
        const segStart = distances[segIndex];
        const segEnd = distances[segIndex + 1] || segStart + 0.01;
        const t = (ledDist - segStart) / (segEnd - segStart);

        const p1 = curve.points[segIndex];
        const p2 = curve.points[segIndex + 1] || p1;
        const ledX = p1.x + t * (p2.x - p1.x);
        const ledY = p1.y + t * (p2.y - p1.y);

        const sp = toSVG(ledX, ledY, scale, centerX);

        // Blinking logic
        const shouldShow = !els.blinkMode.checked || (blinkState ? i % 2 === 0 : i % 2 === 1);

        if (shouldShow) {
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', sp.x);
          circle.setAttribute('cy', sp.y);
          circle.setAttribute('r', '4');
          circle.setAttribute('fill', rainbowColors[i % rainbowColors.length]);
          circle.setAttribute('opacity', '0.9');
          els.archGroup.appendChild(circle);
        }
      }
    }

    // Render ground markers
    const leftEnd = toSVG(-W / 2, 0, scale, centerX);
    const rightEnd = toSVG(W / 2, 0, scale, centerX);

    // Width dimension
    const dimY = GROUND_Y + 25;
    const dimLine = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    dimLine.innerHTML = `
      <line x1="${leftEnd.x}" y1="${dimY}" x2="${rightEnd.x}" y2="${dimY}" stroke="#8b9cb3" stroke-width="1"/>
      <line x1="${leftEnd.x}" y1="${GROUND_Y}" x2="${leftEnd.x}" y2="${dimY + 5}" stroke="#8b9cb3" stroke-width="1"/>
      <line x1="${rightEnd.x}" y1="${GROUND_Y}" x2="${rightEnd.x}" y2="${dimY + 5}" stroke="#8b9cb3" stroke-width="1"/>
      <text x="${centerX}" y="${dimY + 18}" fill="#8b9cb3" font-size="12" text-anchor="middle" font-family="system-ui">${W} ft</text>
    `;
    els.archGroup.appendChild(dimLine);

    // Height dimension
    const apex = toSVG(0, height, scale, centerX);
    const heightLine = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    heightLine.innerHTML = `
      <line x1="${leftEnd.x - 25}" y1="${GROUND_Y}" x2="${leftEnd.x - 25}" y2="${apex.y}" stroke="#8b9cb3" stroke-width="1"/>
      <line x1="${leftEnd.x - 30}" y1="${GROUND_Y}" x2="${leftEnd.x - 20}" y2="${GROUND_Y}" stroke="#8b9cb3" stroke-width="1"/>
      <line x1="${leftEnd.x - 30}" y1="${apex.y}" x2="${leftEnd.x - 20}" y2="${apex.y}" stroke="#8b9cb3" stroke-width="1"/>
      <text x="${leftEnd.x - 35}" y="${(GROUND_Y + apex.y) / 2 + 4}" fill="#8b9cb3" font-size="12" text-anchor="end" font-family="system-ui">${height.toFixed(1)} ft</text>
    `;
    els.archGroup.appendChild(heightLine);

    // Render base angle arcs on both ends
    const arcRadius = 40;  // pixels
    // theta is already in scope from solveForShape() destructuring

    // Left side angle arc
    const leftAngleGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    // Draw arc from horizontal to the tangent angle
    const leftArcEndX = leftEnd.x + arcRadius * Math.cos(-theta);  // Note: SVG Y is inverted
    const leftArcEndY = leftEnd.y - arcRadius * Math.sin(theta);
    const leftArcPath = `M ${leftEnd.x + arcRadius} ${leftEnd.y} A ${arcRadius} ${arcRadius} 0 0 0 ${leftArcEndX} ${leftArcEndY}`;

    leftAngleGroup.innerHTML = `
      <path d="${leftArcPath}" fill="none" stroke="#fbbf24" stroke-width="2"/>
      <line x1="${leftEnd.x}" y1="${leftEnd.y}" x2="${leftEnd.x + arcRadius + 10}" y2="${leftEnd.y}" stroke="#fbbf24" stroke-width="1" stroke-dasharray="4,2"/>
      <text x="${leftEnd.x + arcRadius + 5}" y="${leftEnd.y - 15}" fill="#fbbf24" font-size="11" font-family="system-ui">${baseAngleDeg.toFixed(0)}Â°</text>
    `;
    els.archGroup.appendChild(leftAngleGroup);

    // Right side angle arc (mirrored)
    const rightAngleGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const rightArcEndX = rightEnd.x - arcRadius * Math.cos(-theta);
    const rightArcEndY = rightEnd.y - arcRadius * Math.sin(theta);
    const rightArcPath = `M ${rightEnd.x - arcRadius} ${rightEnd.y} A ${arcRadius} ${arcRadius} 0 0 1 ${rightArcEndX} ${rightArcEndY}`;

    rightAngleGroup.innerHTML = `
      <path d="${rightArcPath}" fill="none" stroke="#fbbf24" stroke-width="2"/>
      <line x1="${rightEnd.x}" y1="${rightEnd.y}" x2="${rightEnd.x - arcRadius - 10}" y2="${rightEnd.y}" stroke="#fbbf24" stroke-width="1" stroke-dasharray="4,2"/>
      <text x="${rightEnd.x - arcRadius - 25}" y="${rightEnd.y - 15}" fill="#fbbf24" font-size="11" font-family="system-ui">${baseAngleDeg.toFixed(0)}Â°</text>
    `;
    els.archGroup.appendChild(rightAngleGroup);
  }

  /**
   * Toggle button handler
   */
  function toggleButton(btn, state) {
    btn.classList.toggle('active', state);
  }

  /**
   * Sync slider and number input
   */
  function syncSliderAndInput(slider, input) {
    slider.addEventListener('input', () => {
      input.value = slider.value;
      render();
    });
    input.addEventListener('input', () => {
      slider.value = input.value;
      render();
    });
  }

  /**
   * Initialize event listeners
   */
  function init() {
    // Sync sliders with number inputs
    syncSliderAndInput(els.widthSlider, els.width);
    syncSliderAndInput(els.archLengthSlider, els.archLength);

    // Other input listeners
    const inputs = [
      els.stickLength, els.cutStrategy,
      els.ledLength, els.ledCount
    ];

    inputs.forEach(el => {
      el.addEventListener('input', render);
    });

    // Viz control buttons
    els.btnHeatmap.addEventListener('click', () => {
      showHeatmap = !showHeatmap;
      toggleButton(els.btnHeatmap, showHeatmap);
      render();
    });

    els.btnLeds.addEventListener('click', () => {
      showLeds = !showLeds;
      toggleButton(els.btnLeds, showLeds);
      render();
    });

    els.btnJoins.addEventListener('click', () => {
      showJoins = !showJoins;
      toggleButton(els.btnJoins, showJoins);
      render();
    });

    // Blink mode
    els.blinkMode.addEventListener('change', () => {
      if (els.blinkMode.checked) {
        blinkInterval = setInterval(() => {
          blinkState = !blinkState;
          if (showLeds) render();
        }, 500);
      } else {
        clearInterval(blinkInterval);
        blinkState = true;
        if (showLeds) render();
      }
    });

    // Initial render
    render();
  }

  init();
})();
</script>
</body>
</html>
