<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>LED Arch Calculator</title>
  <style>
    :root {
      --bg: #0a0e14;
      --card: #111826;
      --border: rgba(255,255,255,0.08);
      --text: #e7eef8;
      --muted: #8b9cb3;
      --accent: #3b82f6;
      --accent-dim: rgba(59,130,246,0.15);
      --success: #10b981;
      --warn-bg: rgba(251,146,60,0.12);
      --warn-border: rgba(251,146,60,0.25);
      --warn-text: #fb923c;
      --tube-a: rgba(96,165,250,0.35);
      --tube-b: rgba(52,211,153,0.35);
      --join: #f472b6;
      --ground: rgba(255,255,255,0.08);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      display: grid;
      grid-template-columns: 380px 1fr;
      gap: 20px;
      min-height: 100vh;
    }
    @media (max-width: 900px) {
      .container { grid-template-columns: 1fr; }
    }
    .panel {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
    }
    h1 {
      font-size: 1.25rem;
      font-weight: 600;
      margin: 0 0 4px;
    }
    .subtitle {
      color: var(--muted);
      font-size: 0.8rem;
      margin: 0 0 20px;
    }
    .section {
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--border);
    }
    .section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
    .section-title {
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
      margin: 0 0 12px;
    }
    label {
      display: block;
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 6px;
    }
    .field { margin-bottom: 14px; }
    .field:last-child { margin-bottom: 0; }
    input[type="number"], input[type="text"], select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: rgba(0,0,0,0.25);
      color: var(--text);
      font-size: 0.9rem;
      transition: border-color 0.2s;
    }
    input:focus, select:focus {
      outline: none;
      border-color: var(--accent);
    }
    input:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    input[type="range"]:disabled {
      opacity: 0.3;
    }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .row-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }

    /* Slider styling */
    .slider-field {
      margin-bottom: 14px;
    }
    .slider-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .slider-row input[type="range"] {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: rgba(255,255,255,0.1);
      -webkit-appearance: none;
      appearance: none;
      cursor: pointer;
    }
    .slider-row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid rgba(255,255,255,0.2);
    }
    .slider-row input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      border: 2px solid rgba(255,255,255,0.2);
    }
    .slider-row input[type="number"] {
      width: 70px;
      flex-shrink: 0;
    }

    /* Toggle switch */
    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 0;
    }
    .toggle-label {
      font-size: 0.85rem;
      color: var(--text);
    }
    .toggle {
      position: relative;
      width: 44px;
      height: 24px;
    }
    .toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      inset: 0;
      background: rgba(255,255,255,0.1);
      border-radius: 24px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .toggle-slider::before {
      content: '';
      position: absolute;
      width: 18px;
      height: 18px;
      left: 3px;
      top: 3px;
      background: white;
      border-radius: 50%;
      transition: transform 0.2s;
    }
    .toggle input:checked + .toggle-slider {
      background: var(--accent);
    }
    .toggle input:checked + .toggle-slider::before {
      transform: translateX(20px);
    }

    /* Results grid */
    .results-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .result-item {
      background: rgba(0,0,0,0.2);
      border-radius: 10px;
      padding: 12px;
    }
    .result-label {
      font-size: 0.7rem;
      color: var(--muted);
      margin-bottom: 4px;
    }
    .result-value {
      font-size: 1rem;
      font-weight: 600;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
    }
    .result-value.success { color: var(--success); }
    .result-value.warn { color: var(--warn-text); }

    /* Warning box */
    .warning {
      margin-top: 14px;
      padding: 12px;
      background: var(--warn-bg);
      border: 1px solid var(--warn-border);
      border-radius: 10px;
      font-size: 0.8rem;
      color: rgba(255,255,255,0.85);
      display: none;
    }
    .warning.visible { display: block; }
    .warning strong { color: var(--warn-text); }

    /* Note box */
    .note {
      margin-top: 12px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.04);
      border-radius: 10px;
      font-size: 0.75rem;
      color: var(--muted);
      line-height: 1.5;
    }

    /* SVG container */
    .viz-panel {
      display: flex;
      flex-direction: column;
    }
    .viz-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .viz-title {
      font-size: 0.9rem;
      font-weight: 600;
    }
    .viz-controls {
      display: flex;
      gap: 8px;
    }
    .viz-btn {
      padding: 6px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: transparent;
      color: var(--muted);
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .viz-btn:hover, .viz-btn.active {
      background: var(--accent-dim);
      border-color: var(--accent);
      color: var(--text);
    }
    svg {
      flex: 1;
      width: 100%;
      min-height: 500px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02) 0%, rgba(0,0,0,0.1) 100%);
      border-radius: 14px;
      border: 1px solid var(--border);
    }

    /* Legend */
    .legend {
      display: flex;
      gap: 16px;
      margin-top: 12px;
      flex-wrap: wrap;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75rem;
      color: var(--muted);
    }
    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    .legend-line {
      width: 20px;
      height: 3px;
      border-radius: 2px;
    }
  </style>
</head>
<body>
<div class="container">
  <!-- Control Panel -->
  <div class="panel">
    <h1>LED Arch Calculator</h1>
    <p class="subtitle">Design a flexible PEX tubing LED arch with pivoting base anchors</p>

    <!-- INPUTS Section -->
    <div class="section">
      <div class="section-title">ðŸ“¥ Inputs</div>
      <div class="slider-field">
        <label for="width">Base width (ft)</label>
        <div class="slider-row">
          <input type="range" id="widthSlider" value="10" min="3" max="20" step="0.5">
          <input type="number" id="width" value="10" min="3" max="20" step="0.5">
        </div>
      </div>
      <div class="slider-field">
        <label for="archLength">Arch length (ft)</label>
        <div class="slider-row">
          <input type="range" id="archLengthSlider" value="16" min="4" max="40" step="0.5">
          <input type="number" id="archLength" value="16" min="4" max="40" step="0.5">
        </div>
      </div>
      <div class="slider-field">
        <label for="baseAngle">Base angle (degrees)</label>
        <div class="slider-row">
          <input type="range" id="baseAngleSlider" value="45" min="15" max="85" step="1">
          <input type="number" id="baseAngle" value="45" min="15" max="85" step="1">
        </div>
      </div>
      <div class="toggle-row">
        <span class="toggle-label">Auto-compute angle from arch length</span>
        <label class="toggle">
          <input type="checkbox" id="autoAngle" checked>
          <span class="toggle-slider"></span>
        </label>
      </div>
      <div class="slider-field">
        <label for="straightLegDistance">Straight leg distance (ft)</label>
        <div class="slider-row">
          <input type="range" id="straightLegDistanceSlider" value="5" min="0" max="15" step="0.1">
          <input type="number" id="straightLegDistance" value="5" min="0" max="15" step="0.1">
        </div>
      </div>
      <div class="note" style="margin-top: 14px;">
        <strong>How it works:</strong> Uses a <em>battered wall</em> curve modelâ€”straighter sides that slope inward like a fortification wall, with a smooth curved top. This creates a visually striking shape that is wider at the base. With auto-angle on, the base angle is optimized for even stress distribution. Turn it off to manually set the pivot angle.
      </div>
    </div>

    <!-- Tubing & Cuts -->
    <div class="section">
      <div class="section-title">Tubing & Cuts</div>
      <div class="row">
        <div class="field">
          <label for="stickLength">PEX stick length (ft)</label>
          <input type="number" id="stickLength" value="10" min="1" max="20" step="0.5">
        </div>
        <div class="field">
          <label for="cutStrategy">Cut strategy</label>
          <select id="cutStrategy">
            <option value="equal">Equal cuts (join at midpoint)</option>
            <option value="offset">Full + cut stick (offset join)</option>
          </select>
        </div>
      </div>
    </div>

    <!-- LED Configuration -->
    <div class="section">
      <div class="section-title">LED Strip Configuration</div>
      <div class="row">
        <div class="field">
          <label for="ledLength">Strip length (ft)</label>
          <input type="number" id="ledLength" value="16.4" min="1" max="100" step="0.1">
        </div>
        <div class="field">
          <label for="ledCount">Number of LEDs</label>
          <input type="number" id="ledCount" value="300" min="10" max="1000" step="1">
        </div>
      </div>
      <div class="toggle-row" style="margin-top: 8px;">
        <span class="toggle-label">Blinking mode</span>
        <label class="toggle">
          <input type="checkbox" id="blinkMode">
          <span class="toggle-slider"></span>
        </label>
      </div>
    </div>

    <!-- DERIVED Section -->
    <div class="section">
      <div class="section-title">ðŸ“¤ Derived Values</div>
      <div class="results-grid">
        <div class="result-item">
          <div class="result-label">Apex height</div>
          <div class="result-value" id="resultHeight">â€”</div>
        </div>
        <div class="result-item">
          <div class="result-label">Base angle</div>
          <div class="result-value" id="resultAngle">â€”</div>
        </div>
        <div class="result-item">
          <div class="result-label">Curvature ratio</div>
          <div class="result-value" id="resultCurvature">â€”</div>
        </div>
        <div class="result-item">
          <div class="result-label">LED fit</div>
          <div class="result-value" id="resultLedFit">â€”</div>
        </div>
      </div>
      <div class="results-grid" style="margin-top: 12px;">
        <div class="result-item">
          <div class="result-label">Cut lengths</div>
          <div class="result-value" id="resultCuts">â€”</div>
        </div>
        <div class="result-item">
          <div class="result-label">Material waste</div>
          <div class="result-value" id="resultWaste">â€”</div>
        </div>
      </div>
      <div class="results-grid" style="margin-top: 12px;">
        <div class="result-item" style="grid-column: span 2;">
          <div class="result-label">Sagitta (5" chord at join)</div>
          <div class="result-value" id="resultCouplingRadius">â€”</div>
        </div>
      </div>
      <div class="warning" id="warning"></div>
    </div>
  </div>

  <!-- Visualization Panel -->
  <div class="panel viz-panel">
    <div class="viz-header">
      <span class="viz-title">Arch Visualization</span>
      <div class="viz-controls">
        <button class="viz-btn active" id="btnHeatmap">Heat Map</button>
        <button class="viz-btn" id="btnLeds">Show LEDs</button>
        <button class="viz-btn" id="btnJoins">Show Joins</button>
      </div>
    </div>
    <svg id="svg" viewBox="0 0 800 500" preserveAspectRatio="xMidYMid meet">
      <defs>
        <linearGradient id="groundGrad" x1="0%" y1="0%" x2="100%" y2="0%">
          <stop offset="0%" stop-color="transparent"/>
          <stop offset="50%" stop-color="rgba(255,255,255,0.1)"/>
          <stop offset="100%" stop-color="transparent"/>
        </linearGradient>
      </defs>
      <!-- Ground line -->
      <line id="ground" x1="50" y1="450" x2="750" y2="450" stroke="url(#groundGrad)" stroke-width="2"/>
      <!-- Arch group -->
      <g id="archGroup"></g>
    </svg>
    <div class="legend">
      <div class="legend-item">
        <div class="legend-line" style="background: linear-gradient(90deg, #22c55e, #eab308, #ef4444);"></div>
        <span>Curvature (low â†’ high)</span>
      </div>
      <div class="legend-item">
        <div class="legend-dot" style="background: #f472b6;"></div>
        <span>Join point</span>
      </div>
      <div class="legend-item">
        <div class="legend-dot" style="background: #22d3ee;"></div>
        <span>Sagitta sample</span>
      </div>
      <div class="legend-item">
        <div class="legend-line" style="background: #fbbf24; height: 2px;"></div>
        <span>Base angle</span>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  'use strict';

  // DOM Elements
  const $ = id => document.getElementById(id);
  const els = {
    width: $('width'),
    widthSlider: $('widthSlider'),
    archLength: $('archLength'),
    archLengthSlider: $('archLengthSlider'),
    baseAngle: $('baseAngle'),
    baseAngleSlider: $('baseAngleSlider'),
    autoAngle: $('autoAngle'),
    straightLegDistance: $('straightLegDistance'),
    straightLegDistanceSlider: $('straightLegDistanceSlider'),
    stickLength: $('stickLength'),
    cutStrategy: $('cutStrategy'),
    ledLength: $('ledLength'),
    ledCount: $('ledCount'),
    blinkMode: $('blinkMode'),
    warning: $('warning'),
    svg: $('svg'),
    archGroup: $('archGroup'),
    resultHeight: $('resultHeight'),
    resultAngle: $('resultAngle'),
    resultCurvature: $('resultCurvature'),
    resultLedFit: $('resultLedFit'),
    resultCuts: $('resultCuts'),
    resultWaste: $('resultWaste'),
    resultCouplingRadius: $('resultCouplingRadius'),
    btnHeatmap: $('btnHeatmap'),
    btnLeds: $('btnLeds'),
    btnJoins: $('btnJoins')
  };

  // State
  let showHeatmap = true;
  let showLeds = false;
  let showJoins = false;
  let blinkState = true;
  let blinkInterval = null;

  // Constants
  const SVG_WIDTH = 800;
  const SVG_HEIGHT = 500;
  const MARGIN = 60;
  const GROUND_Y = 450;
  const CURVE_SAMPLES = 200;

  // Rainbow colors for LEDs
  const rainbowColors = [
    '#ff0000', '#ff4500', '#ff8c00', '#ffd700', '#adff2f',
    '#00ff00', '#00fa9a', '#00ffff', '#1e90ff', '#4169e1',
    '#8a2be2', '#ff00ff', '#ff1493', '#ff69b4'
  ];

  /**
   * Generate cubic Bezier curve with hinged/pivoting ends
   *
   * Physics model:
   * - Flexible tube pinned at both ends with pivot anchors
   * - Ends can rotate inward at angle theta from horizontal
   * - Shorter arch = shallower angle, longer arch = steeper angle
   *
   * @param {number} W - Width at ground (distance between anchors)
   * @param {number} theta - Base angle in radians (from horizontal)
   * @param {number} d - Control point distance from anchor
   */
  function generateBezierCurve(W, theta, d) {
    const points = [];

    // Anchor points at ground level
    const P0 = { x: -W / 2, y: 0 };
    const P3 = { x: W / 2, y: 0 };

    // Control points - angled inward from anchors
    // Left control point: rises at angle theta
    const P1 = {
      x: P0.x + d * Math.cos(theta),
      y: P0.y + d * Math.sin(theta)
    };
    // Right control point: mirrors left (rises at angle theta from right)
    const P2 = {
      x: P3.x - d * Math.cos(theta),
      y: P3.y + d * Math.sin(theta)
    };

    for (let i = 0; i <= CURVE_SAMPLES; i++) {
      const t = i / CURVE_SAMPLES;
      const mt = 1 - t;
      const mt2 = mt * mt;
      const mt3 = mt2 * mt;
      const t2 = t * t;
      const t3 = t2 * t;

      points.push({
        x: mt3 * P0.x + 3 * mt2 * t * P1.x + 3 * mt * t2 * P2.x + t3 * P3.x,
        y: mt3 * P0.y + 3 * mt2 * t * P1.y + 3 * mt * t2 * P2.y + t3 * P3.y,
        t
      });
    }

    return { points, P0, P1, P2, P3, theta, d };
  }

  /**
   * Generate an elastica curve using numerical integration.
   *
   * The elastica is the shape that minimizes bending energy for an inextensible
   * elastic rod. It naturally distributes curvature more evenly than a Bezier.
   *
   * Uses a shooting method to solve the elastica ODEs:
   *   dÎ¸/ds = Îº (curvature)
   *   dÎº/ds = -Î»Â·sin(Î¸) (moment equation)
   *   dx/ds = cos(Î¸)
   *   dy/ds = sin(Î¸)
   *
   * @param {number} W - Width at ground (distance between anchors)
   * @param {number} L - Total arc length
   * @param {number} theta0 - Base angle in radians (angle at left anchor)
   */
  function generateElasticaCurve(W, L, theta0) {
    const numSteps = CURVE_SAMPLES;
    const ds = L / numSteps;

    /**
     * Integrate the elastica ODEs given initial conditions and lambda
     */
    function integrate(theta0, kappa0, lambda) {
      const points = [];
      let theta = theta0;
      let kappa = kappa0;
      let x = -W / 2;
      let y = 0;

      points.push({ x, y, theta, kappa });

      for (let i = 0; i < numSteps; i++) {
        // RK4 integration for better accuracy
        const k1_theta = kappa;
        const k1_kappa = -lambda * Math.sin(theta);
        const k1_x = Math.cos(theta);
        const k1_y = Math.sin(theta);

        const theta_mid1 = theta + 0.5 * ds * k1_theta;
        const kappa_mid1 = kappa + 0.5 * ds * k1_kappa;
        const k2_theta = kappa_mid1;
        const k2_kappa = -lambda * Math.sin(theta_mid1);
        const k2_x = Math.cos(theta_mid1);
        const k2_y = Math.sin(theta_mid1);

        const theta_mid2 = theta + 0.5 * ds * k2_theta;
        const kappa_mid2 = kappa + 0.5 * ds * k2_kappa;
        const k3_theta = kappa_mid2;
        const k3_kappa = -lambda * Math.sin(theta_mid2);
        const k3_x = Math.cos(theta_mid2);
        const k3_y = Math.sin(theta_mid2);

        const theta_end = theta + ds * k3_theta;
        const kappa_end = kappa + ds * k3_kappa;
        const k4_theta = kappa_end;
        const k4_kappa = -lambda * Math.sin(theta_end);
        const k4_x = Math.cos(theta_end);
        const k4_y = Math.sin(theta_end);

        theta += ds * (k1_theta + 2*k2_theta + 2*k3_theta + k4_theta) / 6;
        kappa += ds * (k1_kappa + 2*k2_kappa + 2*k3_kappa + k4_kappa) / 6;
        x += ds * (k1_x + 2*k2_x + 2*k3_x + k4_x) / 6;
        y += ds * (k1_y + 2*k2_y + 2*k3_y + k4_y) / 6;

        points.push({ x, y, theta, kappa });
      }

      return points;
    }

    /**
     * For a symmetric arch, we need:
     * - x(L) = W/2
     * - y(L) = 0
     * - Î¸(L) = Ï€ - Î¸â‚€ (symmetric exit angle)
     *
     * We search for kappa0 and lambda that satisfy these constraints.
     * For a symmetric elastica, kappa0 = 0 at the ends (inflection points).
     */

    // Use shooting method to find lambda that gives correct end position
    // For a pinned-pinned symmetric elastica with angle theta0, we search for lambda

    let lambdaLo = 0.01;
    let lambdaHi = 50;
    let bestPoints = null;
    let bestError = Infinity;

    // Binary search for lambda
    for (let iter = 0; iter < 60; iter++) {
      const lambdaMid = (lambdaLo + lambdaHi) / 2;

      // For symmetric arch, kappa0 should be such that curvature is symmetric
      // Start with kappa0 proportional to lambda and theta0
      const kappa0 = Math.sqrt(2 * lambdaMid * (1 - Math.cos(theta0)));

      const points = integrate(theta0, kappa0, lambdaMid);
      const endPoint = points[points.length - 1];

      // Error: how far from target end position
      const xError = endPoint.x - W / 2;
      const yError = endPoint.y;
      const error = Math.sqrt(xError * xError + yError * yError);

      if (error < bestError) {
        bestError = error;
        bestPoints = points;
      }

      // Adjust lambda based on where we ended up
      // Higher lambda = tighter curve = less horizontal travel
      if (endPoint.x > W / 2) {
        lambdaLo = lambdaMid;  // Need tighter curve
      } else {
        lambdaHi = lambdaMid;  // Need looser curve
      }

      if (error < 0.001) break;
    }

    // Fine-tune with kappa0 adjustment
    const lambda = (lambdaLo + lambdaHi) / 2;
    let kappa0Lo = 0;
    let kappa0Hi = 5;

    for (let iter = 0; iter < 40; iter++) {
      const kappa0Mid = (kappa0Lo + kappa0Hi) / 2;
      const points = integrate(theta0, kappa0Mid, lambda);
      const endPoint = points[points.length - 1];

      const error = Math.sqrt(
        Math.pow(endPoint.x - W/2, 2) +
        Math.pow(endPoint.y, 2)
      );

      if (error < bestError) {
        bestError = error;
        bestPoints = points;
      }

      // Adjust kappa0: higher = curves up faster initially
      if (endPoint.y > 0) {
        kappa0Hi = kappa0Mid;
      } else {
        kappa0Lo = kappa0Mid;
      }

      if (error < 0.001) break;
    }

    // If we still have significant error, fall back to a simpler approach:
    // Use energy-minimizing relaxation
    if (bestError > 0.1 || !bestPoints) {
      bestPoints = generateRelaxedElastica(W, L, theta0);
    }

    return { points: bestPoints, theta: theta0 };
  }

  /**
   * Generate a battered wall curve - straighter sides that slope inward.
   * Creates a shape similar to a fortification wall: wider at the base,
   * with relatively straight sides tapering inward, and a curved top.
   *
   * @param {number} W - Width at ground (distance between anchors)
   * @param {number} L - Total arc length
   * @param {number} theta0 - Base angle in radians (angle at anchors from horizontal)
   * @param {number} straightLegDist - Length of each straight leg section (in feet)
   */
  function generateBatteredWallCurve(W, L, theta0, straightLegDist) {
    const n = CURVE_SAMPLES;

    // For a battered wall, we want relatively straight sides with a curved top
    // straightLegDist: arc length of each straight leg section
    // Default to 65% of each half if not specified
    const straightLen = straightLegDist !== undefined ? straightLegDist : (L * 0.65) / 2;

    // Clamp to valid range: 0 to 40% of total arc per side
    const maxStraightLen = L * 0.4;
    const clampedStraightLen = Math.max(0, Math.min(straightLen, maxStraightLen));

    // Total arc is divided into:
    // - Left straight: clampedStraightLen
    // - Top curve: L - 2 * clampedStraightLen
    // - Right straight: clampedStraightLen

    // Calculate the ratio for sample distribution
    const straightRatio = (2 * clampedStraightLen) / L;
    const curveLen = L - 2 * clampedStraightLen;   // Length of top curve

    // Straight sides go at angle theta0
    const dxStraight = clampedStraightLen * Math.cos(theta0);
    const dyStraight = clampedStraightLen * Math.sin(theta0);

    // Points where straight sections end (top of the walls)
    const leftTop = { x: -W/2 + dxStraight, y: dyStraight };
    const rightTop = { x: W/2 - dxStraight, y: dyStraight };

    // Calculate samples for each section
    const straightSamples = Math.floor(n * straightRatio / 2);
    const curveSamples = n - 2 * straightSamples;

    const points = [];

    // LEFT STRAIGHT SECTION - goes from bottom left up at angle theta0
    for (let i = 0; i <= straightSamples; i++) {
      const t = i / straightSamples;
      points.push({
        x: -W/2 + t * dxStraight,
        y: t * dyStraight
      });
    }

    // TOP CURVED SECTION - connects the two wall tops with a smooth curve
    // Use a cubic Bezier for smooth transition
    // The curve should be tangent to the walls at the connection points

    // Tangent direction at left top (continuing at angle theta0)
    const leftTangentX = Math.cos(theta0);
    const leftTangentY = Math.sin(theta0);

    // Tangent direction at right top (coming down at angle pi - theta0)
    const rightTangentX = -Math.cos(theta0);
    const rightTangentY = Math.sin(theta0);

    // Helper function to generate Bezier points for a given control point distance
    function generateBezierPoints(cpDist, numSamples) {
      const P0 = leftTop;
      const P1 = {
        x: leftTop.x + cpDist * leftTangentX,
        y: leftTop.y + cpDist * leftTangentY
      };
      const P2 = {
        x: rightTop.x + cpDist * rightTangentX,
        y: rightTop.y + cpDist * rightTangentY
      };
      const P3 = rightTop;

      const bezierPoints = [P0];
      for (let i = 1; i <= numSamples; i++) {
        const t = i / numSamples;
        const mt = 1 - t;
        const mt2 = mt * mt;
        const mt3 = mt2 * mt;
        const t2 = t * t;
        const t3 = t2 * t;

        bezierPoints.push({
          x: mt3 * P0.x + 3 * mt2 * t * P1.x + 3 * mt * t2 * P2.x + t3 * P3.x,
          y: mt3 * P0.y + 3 * mt2 * t * P1.y + 3 * mt * t2 * P2.y + t3 * P3.y
        });
      }
      return bezierPoints;
    }

    // Helper to calculate arc length of a set of points
    function bezierArcLength(bezierPoints) {
      let len = 0;
      for (let i = 1; i < bezierPoints.length; i++) {
        const dx = bezierPoints[i].x - bezierPoints[i - 1].x;
        const dy = bezierPoints[i].y - bezierPoints[i - 1].y;
        len += Math.sqrt(dx * dx + dy * dy);
      }
      return len;
    }

    // Use binary search to find the cpDist that produces the target arc length
    // for the curved section (curveLen)
    let cpDistLow = curveLen * 0.1;
    let cpDistHigh = curveLen * 2.0;
    let cpDist = curveLen * 0.4; // Initial guess
    const targetLen = curveLen;
    const tolerance = 0.001; // 0.001 ft tolerance

    for (let iter = 0; iter < 50; iter++) {
      cpDist = (cpDistLow + cpDistHigh) / 2;
      const testPoints = generateBezierPoints(cpDist, curveSamples);
      const actualLen = bezierArcLength(testPoints);

      if (Math.abs(actualLen - targetLen) < tolerance) {
        break; // Found good enough cpDist
      }

      if (actualLen < targetLen) {
        cpDistLow = cpDist; // Need longer curve, increase cpDist
      } else {
        cpDistHigh = cpDist; // Curve too long, decrease cpDist
      }
    }

    // Generate final Bezier points with the calibrated cpDist
    const P0 = leftTop;
    const P1 = {
      x: leftTop.x + cpDist * leftTangentX,
      y: leftTop.y + cpDist * leftTangentY
    };
    const P2 = {
      x: rightTop.x + cpDist * rightTangentX,
      y: rightTop.y + cpDist * rightTangentY
    };
    const P3 = rightTop;

    // Generate Bezier curve points (skip first point, already added)
    for (let i = 1; i <= curveSamples; i++) {
      const t = i / curveSamples;
      const mt = 1 - t;
      const mt2 = mt * mt;
      const mt3 = mt2 * mt;
      const t2 = t * t;
      const t3 = t2 * t;

      points.push({
        x: mt3 * P0.x + 3 * mt2 * t * P1.x + 3 * mt * t2 * P2.x + t3 * P3.x,
        y: mt3 * P0.y + 3 * mt2 * t * P1.y + 3 * mt * t2 * P2.y + t3 * P3.y
      });
    }

    // RIGHT STRAIGHT SECTION - goes from top right down at angle theta0
    for (let i = 1; i <= straightSamples; i++) {
      const t = i / straightSamples;
      points.push({
        x: rightTop.x + t * dxStraight,
        y: rightTop.y - t * dyStraight
      });
    }

    return { points, theta: theta0 };
  }

  /**
   * Generate elastica using discrete relaxation.
   * This is a fallback that always converges.
   */
  function generateRelaxedElastica(W, L, theta0) {
    const n = CURVE_SAMPLES;
    const segLen = L / n;

    // Initialize with a shape that respects the base angle
    const points = [];
    for (let i = 0; i <= n; i++) {
      const t = i / n;
      // Start with shape based on theta0 - use the angle to influence initial y
      const progress = Math.sin(Math.PI * t);  // 0 -> 1 -> 0
      const x = -W/2 + t * W;
      // Height scales with the base angle - steeper angle = taller arch
      const y = progress * L * Math.sin(theta0) * 0.5;
      points.push({ x, y });
    }

    // Pin endpoints
    points[0] = { x: -W/2, y: 0 };
    points[n] = { x: W/2, y: 0 };

    // Relaxation iterations
    for (let iter = 0; iter < 200; iter++) {
      // Calculate current segment lengths
      const lengths = [];
      for (let i = 0; i < n; i++) {
        lengths.push(Math.hypot(
          points[i+1].x - points[i].x,
          points[i+1].y - points[i].y
        ));
      }

      // Move interior points to minimize bending energy
      // Skip points[1] and points[n-1] as they are constrained by the base angle
      for (let i = 2; i < n - 1; i++) {
        const prev = points[i-1];
        const curr = points[i];
        const next = points[i+1];

        // Vector from prev to next (chord)
        const chordX = next.x - prev.x;
        const chordY = next.y - prev.y;
        const chordLen = Math.hypot(chordX, chordY);

        // Move point toward the midpoint of the chord (reduces curvature)
        // but also upward (to maintain arch shape)
        const midX = (prev.x + next.x) / 2;
        const midY = (prev.y + next.y) / 2;

        // Blend between current position and smoothed position
        const alpha = 0.3;
        points[i] = {
          x: curr.x * (1 - alpha) + midX * alpha,
          y: curr.y * (1 - alpha) + midY * alpha
        };
      }

      // Enforce arc length constraint by rescaling
      let totalLen = 0;
      for (let i = 0; i < n; i++) {
        totalLen += Math.hypot(
          points[i+1].x - points[i].x,
          points[i+1].y - points[i].y
        );
      }

      // Scale y coordinates to match target length
      // (keeping x fixed maintains width)
      if (Math.abs(totalLen - L) > 0.01) {
        const scale = L / totalLen;
        for (let i = 1; i < n; i++) {
          points[i].y *= scale;
        }
      }

      // Re-pin endpoints
      points[0] = { x: -W/2, y: 0 };
      points[n] = { x: W/2, y: 0 };

      // Enforce base angle by adjusting first and last interior points
      // This must happen every iteration to maintain the desired angle
      const d = segLen;
      points[1] = {
        x: -W/2 + d * Math.cos(theta0),
        y: d * Math.sin(theta0)
      };
      points[n-1] = {
        x: W/2 - d * Math.cos(theta0),
        y: d * Math.sin(theta0)
      };
    }

    return points;
  }

  /**
   * Calculate arc length of curve using numerical integration
   */
  function calculateArcLength(points) {
    let length = 0;
    for (let i = 1; i < points.length; i++) {
      const dx = points[i].x - points[i - 1].x;
      const dy = points[i].y - points[i - 1].y;
      length += Math.sqrt(dx * dx + dy * dy);
    }
    return length;
  }

  /**
   * Calculate curvature at each point using Menger curvature formula
   */
  function calculateCurvature(points) {
    const curvatures = [0]; // First point

    for (let i = 1; i < points.length - 1; i++) {
      const p0 = points[i - 1];
      const p1 = points[i];
      const p2 = points[i + 1];

      // Side lengths
      const a = Math.hypot(p1.x - p0.x, p1.y - p0.y);
      const b = Math.hypot(p2.x - p1.x, p2.y - p1.y);
      const c = Math.hypot(p2.x - p0.x, p2.y - p0.y);

      // Triangle area using cross product
      const area = Math.abs((p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x)) / 2;

      // Menger curvature: k = 4 * area / (a * b * c)
      const denom = a * b * c;
      curvatures.push(denom > 0.0001 ? (4 * area) / denom : 0);
    }

    curvatures.push(0); // Last point
    return curvatures;
  }

  /**
   * Calculate curvature concentration metric (q95/q50)
   */
  function calculateConcentration(curvatures) {
    const sorted = [...curvatures].filter(k => k > 0).sort((a, b) => a - b);
    if (sorted.length < 10) return 1;

    const q50 = sorted[Math.floor(sorted.length * 0.5)];
    const q95 = sorted[Math.floor(sorted.length * 0.95)];

    return q50 > 0 ? q95 / q50 : 1;
  }

  /**
   * Calculate sagitta at the join point for coupling fabrication.
   * The sagitta is the height of the arc above a chord of given length.
   * Formula: s = R - sqrt(RÂ² - (c/2)Â²) where R is radius, c is chord length.
   *
   * @param {Array} points - Curve points
   * @param {Array} curvatures - Curvature at each point
   * @param {number} joinPosition - Position of join (0-1 fraction of arc length)
   * @param {number} chordInches - Chord length in inches (e.g., 5")
   * @returns {Object} { sagitta, joinIndex } sagitta in inches
   */
  function calculateCouplingSagitta(points, curvatures, joinPosition, chordInches) {
    if (joinPosition === null) return null;

    // Calculate cumulative arc distances (in feet)
    const distances = [0];
    for (let i = 1; i < points.length; i++) {
      const dx = points[i].x - points[i - 1].x;
      const dy = points[i].y - points[i - 1].y;
      distances.push(distances[i - 1] + Math.sqrt(dx * dx + dy * dy));
    }

    const totalLength = distances[distances.length - 1];
    const joinDist = joinPosition * totalLength;  // arc distance to join in feet

    // Find index for join point
    let joinIndex = 0;
    for (let i = 1; i < distances.length; i++) {
      if (distances[i] >= joinDist) {
        joinIndex = i;
        break;
      }
    }

    // Get curvature at join point (curvature is in 1/feet)
    const curvature = curvatures[joinIndex] || 0;

    // Convert curvature to radius in inches
    // radius (ft) = 1 / curvature (1/ft), then convert to inches
    const radiusInches = curvature > 0.0001 ? (1 / curvature) * 12 : Infinity;

    // Calculate sagitta: s = R - sqrt(RÂ² - (c/2)Â²)
    // For a 5" chord, (c/2) = 2.5"
    const halfChord = chordInches / 2;
    let sagitta;
    if (radiusInches === Infinity) {
      sagitta = 0;  // Straight line has no sagitta
    } else if (radiusInches < halfChord) {
      // Radius smaller than half chord means very tight curve
      // In this case, sagitta would be approximately the diameter
      sagitta = radiusInches * 2;
    } else {
      sagitta = radiusInches - Math.sqrt(radiusInches * radiusInches - halfChord * halfChord);
    }

    return {
      sagitta,
      radiusInches,
      joinIndex
    };
  }

  /**
   * Find the optimal base angle that minimizes stress concentration.
   * Uses golden section search to find the angle that distributes
   * curvature most evenly along the arch.
   */
  function findOptimalAngle(W, L, straightLegDist) {
    const phi = (1 + Math.sqrt(5)) / 2;  // Golden ratio

    // Angle bounds in radians (15Â° to 85Â°)
    let a = 15 * Math.PI / 180;
    let b = 85 * Math.PI / 180;

    // Tolerance for convergence
    const tol = 0.5 * Math.PI / 180;  // 0.5 degree

    // Function to evaluate: stress concentration for a given angle
    function evaluate(theta) {
      const curve = generateBatteredWallCurve(W, L, theta, straightLegDist);
      const curvatures = calculateCurvature(curve.points);
      return calculateConcentration(curvatures);
    }

    // Golden section search for minimum
    let c = b - (b - a) / phi;
    let d = a + (b - a) / phi;
    let fc = evaluate(c);
    let fd = evaluate(d);

    for (let iter = 0; iter < 30 && (b - a) > tol; iter++) {
      if (fc < fd) {
        b = d;
        d = c;
        fd = fc;
        c = b - (b - a) / phi;
        fc = evaluate(c);
      } else {
        a = c;
        c = d;
        fc = fd;
        d = a + (b - a) / phi;
        fd = evaluate(d);
      }
    }

    return (a + b) / 2;
  }

  /**
   * Solve for the arch shape given width and target arc length.
   *
   * The angle theta is derived from the length-to-width ratio:
   * - Short arch (L close to W) = shallow angle
   * - Long arch (L much greater than W) = steep angle
   *
   * The control point distance d is then computed to achieve the exact arc length.
   * A constraint prevents loops: control points must not cross the center.
   */
  function solveForShape(W, targetLength) {
    // Clamp length to valid range
    // Note: This function is kept for backwards compatibility but elastica is preferred
    const minLen = W;
    const maxLen = W * 3.0;
    const L = Math.max(minLen, Math.min(maxLen, targetLength));

    // Compute angle from length ratio
    // As L/W increases, angle increases
    const ratio = (L - minLen) / (maxLen - minLen);

    // Angle ranges from ~20Â° (shallow) to ~80Â° (steep)
    const thetaMin = 20 * Math.PI / 180;
    const thetaMax = 80 * Math.PI / 180;
    const theta = thetaMin + ratio * (thetaMax - thetaMin);

    // Maximum d to prevent loops: P1.x must stay < 0
    // P1.x = -W/2 + d*cos(theta) < 0
    // d < W / (2*cos(theta))
    const maxD = (W / (2 * Math.cos(theta))) * 0.95;

    // Binary search for d that gives target arc length
    let lo = 0.1;
    let hi = Math.min(maxD, W * 2);

    for (let iter = 0; iter < 50; iter++) {
      const mid = (lo + hi) / 2;
      const { points } = generateBezierCurve(W, theta, mid);
      const len = calculateArcLength(points);

      if (Math.abs(len - L) < 0.001) break;

      if (len < L) {
        lo = mid;  // Need larger d for longer arc
      } else {
        hi = mid;  // Need smaller d for shorter arc
      }
    }

    const d = (lo + hi) / 2;
    return { theta, d };
  }

  /**
   * Get the apex height from curve points
   */
  function getApexHeight(points) {
    return Math.max(...points.map(p => p.y));
  }

  /**
   * Get curvature color (green â†’ yellow â†’ red)
   */
  function getCurvatureColor(k, maxK) {
    const ratio = Math.min(k / maxK, 1);

    if (ratio < 0.5) {
      // Green to Yellow
      const t = ratio * 2;
      const r = Math.round(34 + t * (234 - 34));
      const g = Math.round(197 + t * (179 - 197));
      const b = Math.round(94 + t * (8 - 94));
      return `rgb(${r},${g},${b})`;
    } else {
      // Yellow to Red
      const t = (ratio - 0.5) * 2;
      const r = Math.round(234 + t * (239 - 234));
      const g = Math.round(179 - t * 179);
      const b = Math.round(8 - t * 8);
      return `rgb(${r},${g},${b})`;
    }
  }

  /**
   * Transform coordinates to SVG space
   */
  function toSVG(x, y, scale, centerX) {
    return {
      x: centerX + x * scale,
      y: GROUND_Y - y * scale
    };
  }

  /**
   * Calculate cut information
   */
  function calculateCuts(tubeLength, stickLength, strategy) {
    const sticksNeeded = Math.ceil(tubeLength / stickLength);
    const totalMaterial = sticksNeeded * stickLength;
    const waste = totalMaterial - tubeLength;

    let cuts, joinPosition;

    if (strategy === 'equal') {
      // Equal cuts on both sides, join at midpoint
      const cutLen = tubeLength / 2;
      cuts = `2 Ã— ${cutLen.toFixed(2)} ft`;
      joinPosition = 0.5;
    } else {
      // One full stick + cut stick
      if (tubeLength <= stickLength) {
        cuts = `1 Ã— ${tubeLength.toFixed(2)} ft`;
        joinPosition = null;
      } else {
        const remainder = tubeLength - stickLength;
        cuts = `${stickLength} ft + ${remainder.toFixed(2)} ft`;
        joinPosition = stickLength / tubeLength;
      }
    }

    return { cuts, waste, sticksNeeded, joinPosition };
  }

  /**
   * Calculate LED fit information
   */
  function calculateLedFit(tubeLength, ledLength) {
    if (ledLength >= tubeLength) {
      const trim = ledLength - tubeLength;
      return {
        status: trim > 0 ? 'trim' : 'exact',
        message: trim > 0 ? `Trim ${trim.toFixed(2)} ft` : 'Perfect fit',
        coverage: 1,
        gap: 0,
        trim
      };
    } else {
      const gap = (tubeLength - ledLength) / 2;
      return {
        status: 'gap',
        message: `Gap ${gap.toFixed(2)} ft each end`,
        coverage: ledLength / tubeLength,
        gap,
        trim: 0
      };
    }
  }

  /**
   * Main render function
   */
  function render() {
    const W = parseFloat(els.width.value) || 10;
    const L = parseFloat(els.archLength.value) || 16;
    const straightLegDist = parseFloat(els.straightLegDistance.value) || 5;
    const stickLen = parseFloat(els.stickLength.value) || 10;
    const cutStrategy = els.cutStrategy.value;
    const ledLen = parseFloat(els.ledLength.value) || 16.4;
    const ledNum = parseInt(els.ledCount.value) || 300;

    // Validate: arch length must be at least equal to base width
    // Using elastica physics, we can handle much longer arches (up to ~Ï€ ratio for a full loop)
    const minLength = W;
    const maxLength = W * 3.0;  // Elastica can handle higher ratios smoothly
    const clampedL = Math.max(minLength, Math.min(maxLength, L));

    // Determine theta: auto-compute or use manual value
    let theta;
    if (els.autoAngle.checked) {
      // Find the optimal angle that minimizes stress concentration
      theta = findOptimalAngle(W, clampedL, straightLegDist);
      // Update the angle slider to show the computed value
      const angleDeg = Math.round(theta * 180 / Math.PI);
      els.baseAngle.value = angleDeg;
      els.baseAngleSlider.value = angleDeg;
    } else {
      // Use manual angle
      theta = parseFloat(els.baseAngle.value) * Math.PI / 180;
    }

    // Generate battered wall curve (straighter sides, curved top)
    const curve = generateBatteredWallCurve(W, clampedL, theta, straightLegDist);
    const length = calculateArcLength(curve.points);
    const height = getApexHeight(curve.points);
    const baseAngleRad = theta;
    const baseAngleDeg = baseAngleRad * (180 / Math.PI);

    const curvatures = calculateCurvature(curve.points);
    const concentration = calculateConcentration(curvatures);
    const maxCurvature = Math.max(...curvatures);
    const cutInfo = calculateCuts(length, stickLen, cutStrategy);
    const ledFit = calculateLedFit(length, ledLen);
    const couplingSagitta = calculateCouplingSagitta(curve.points, curvatures, cutInfo.joinPosition, 5);

    // Update results
    els.resultHeight.textContent = `${height.toFixed(2)} ft`;
    els.resultAngle.textContent = `${baseAngleDeg.toFixed(1)}Â°`;
    els.resultCurvature.textContent = `${concentration.toFixed(2)}Ã—`;
    els.resultCurvature.className = 'result-value' + (concentration > 1.5 ? ' warn' : ' success');

    els.resultLedFit.textContent = ledFit.message;
    els.resultLedFit.className = 'result-value' + (ledFit.status === 'exact' ? ' success' : '');

    els.resultCuts.textContent = cutInfo.cuts;
    els.resultWaste.textContent = `${cutInfo.waste.toFixed(2)} ft`;
    els.resultWaste.className = 'result-value' + (cutInfo.waste > 2 ? ' warn' : '');

    // Update sagitta display
    if (couplingSagitta) {
      const sagittaStr = couplingSagitta.sagitta.toFixed(3);
      els.resultCouplingRadius.textContent = `${sagittaStr}"`;
    } else {
      els.resultCouplingRadius.textContent = 'No join';
    }

    // Warning for invalid length
    if (L < minLength) {
      els.warning.innerHTML = `<strong>Warning:</strong> Arch length must be at least equal to base width. Min: ${minLength.toFixed(1)} ft.`;
      els.warning.classList.add('visible');
    } else if (L > maxLength) {
      els.warning.innerHTML = `<strong>Warning:</strong> Arch length too long for smooth curve. Max: ${maxLength.toFixed(1)} ft.`;
      els.warning.classList.add('visible');
    } else {
      els.warning.classList.remove('visible');
    }

    // Calculate SVG scale
    const maxDim = Math.max(W, height) * 1.3;
    const scale = (SVG_WIDTH - MARGIN * 2) / maxDim;
    const centerX = SVG_WIDTH / 2;

    // Clear previous rendering
    els.archGroup.innerHTML = '';

    // Render tube segments with curvature heat map
    if (showHeatmap) {
      for (let i = 0; i < curve.points.length - 1; i++) {
        const p1 = toSVG(curve.points[i].x, curve.points[i].y, scale, centerX);
        const p2 = toSVG(curve.points[i + 1].x, curve.points[i + 1].y, scale, centerX);
        const color = getCurvatureColor(curvatures[i], maxCurvature);

        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', p1.x);
        line.setAttribute('y1', p1.y);
        line.setAttribute('x2', p2.x);
        line.setAttribute('y2', p2.y);
        line.setAttribute('stroke', color);
        line.setAttribute('stroke-width', '14');
        line.setAttribute('stroke-linecap', 'round');
        line.setAttribute('opacity', '0.7');
        els.archGroup.appendChild(line);
      }
    } else {
      // Simple tube rendering
      const pathData = curve.points.map((p, i) => {
        const sp = toSVG(p.x, p.y, scale, centerX);
        return (i === 0 ? 'M' : 'L') + sp.x.toFixed(1) + ',' + sp.y.toFixed(1);
      }).join(' ');

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', pathData);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', 'rgba(96,165,250,0.5)');
      path.setAttribute('stroke-width', '14');
      path.setAttribute('stroke-linecap', 'round');
      els.archGroup.appendChild(path);
    }

    // Render join point
    if (showJoins && cutInfo.joinPosition !== null) {
      const joinIndex = Math.floor(cutInfo.joinPosition * (curve.points.length - 1));
      const jp = curve.points[joinIndex];
      const sjp = toSVG(jp.x, jp.y, scale, centerX);

      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', sjp.x);
      circle.setAttribute('cy', sjp.y);
      circle.setAttribute('r', '10');
      circle.setAttribute('fill', '#f472b6');
      circle.setAttribute('stroke', 'white');
      circle.setAttribute('stroke-width', '2');
      els.archGroup.appendChild(circle);

      // Join label
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', sjp.x + 15);
      text.setAttribute('y', sjp.y - 10);
      text.setAttribute('fill', '#f472b6');
      text.setAttribute('font-size', '12');
      text.setAttribute('font-family', 'system-ui');
      text.textContent = 'Join';
      els.archGroup.appendChild(text);

      // Render sagitta indicator at join point
      if (couplingSagitta) {
        // Sagitta label below the join point
        const sagittaText = couplingSagitta.sagitta.toFixed(3) + '"';
        const sagittaLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        sagittaLabel.setAttribute('x', sjp.x);
        sagittaLabel.setAttribute('y', sjp.y + 25);
        sagittaLabel.setAttribute('fill', '#22d3ee');
        sagittaLabel.setAttribute('font-size', '11');
        sagittaLabel.setAttribute('font-family', 'system-ui');
        sagittaLabel.setAttribute('text-anchor', 'middle');
        sagittaLabel.textContent = `s=${sagittaText}`;
        els.archGroup.appendChild(sagittaLabel);
      }
    }

    // Render LEDs
    if (showLeds) {
      // Calculate LED positions along curve
      const totalCurveLen = length;
      const ledSpacing = ledLen / ledNum;

      // Calculate cumulative distances
      const distances = [0];
      for (let i = 1; i < curve.points.length; i++) {
        const dx = curve.points[i].x - curve.points[i - 1].x;
        const dy = curve.points[i].y - curve.points[i - 1].y;
        distances.push(distances[i - 1] + Math.sqrt(dx * dx + dy * dy));
      }

      // LED strip position
      const startDist = ledFit.gap;
      const endDist = startDist + ledLen;

      // Render each LED
      for (let i = 0; i < ledNum; i++) {
        const ledDist = startDist + (i + 0.5) * ledSpacing;
        if (ledDist > totalCurveLen) break;

        // Find position on curve
        let segIndex = 0;
        for (let j = 1; j < distances.length; j++) {
          if (distances[j] >= ledDist) {
            segIndex = j - 1;
            break;
          }
        }

        // Interpolate position
        const segStart = distances[segIndex];
        const segEnd = distances[segIndex + 1] || segStart + 0.01;
        const t = (ledDist - segStart) / (segEnd - segStart);

        const p1 = curve.points[segIndex];
        const p2 = curve.points[segIndex + 1] || p1;
        const ledX = p1.x + t * (p2.x - p1.x);
        const ledY = p1.y + t * (p2.y - p1.y);

        const sp = toSVG(ledX, ledY, scale, centerX);

        // Blinking logic
        const shouldShow = !els.blinkMode.checked || (blinkState ? i % 2 === 0 : i % 2 === 1);

        if (shouldShow) {
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', sp.x);
          circle.setAttribute('cy', sp.y);
          circle.setAttribute('r', '4');
          circle.setAttribute('fill', rainbowColors[i % rainbowColors.length]);
          circle.setAttribute('opacity', '0.9');
          els.archGroup.appendChild(circle);
        }
      }
    }

    // Render ground markers
    const leftEnd = toSVG(-W / 2, 0, scale, centerX);
    const rightEnd = toSVG(W / 2, 0, scale, centerX);

    // Width dimension
    const dimY = GROUND_Y + 25;
    const dimLine = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    dimLine.innerHTML = `
      <line x1="${leftEnd.x}" y1="${dimY}" x2="${rightEnd.x}" y2="${dimY}" stroke="#8b9cb3" stroke-width="1"/>
      <line x1="${leftEnd.x}" y1="${GROUND_Y}" x2="${leftEnd.x}" y2="${dimY + 5}" stroke="#8b9cb3" stroke-width="1"/>
      <line x1="${rightEnd.x}" y1="${GROUND_Y}" x2="${rightEnd.x}" y2="${dimY + 5}" stroke="#8b9cb3" stroke-width="1"/>
      <text x="${centerX}" y="${dimY + 18}" fill="#8b9cb3" font-size="12" text-anchor="middle" font-family="system-ui">${W} ft</text>
    `;
    els.archGroup.appendChild(dimLine);

    // Height dimension
    const apex = toSVG(0, height, scale, centerX);
    const heightLine = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    heightLine.innerHTML = `
      <line x1="${leftEnd.x - 25}" y1="${GROUND_Y}" x2="${leftEnd.x - 25}" y2="${apex.y}" stroke="#8b9cb3" stroke-width="1"/>
      <line x1="${leftEnd.x - 30}" y1="${GROUND_Y}" x2="${leftEnd.x - 20}" y2="${GROUND_Y}" stroke="#8b9cb3" stroke-width="1"/>
      <line x1="${leftEnd.x - 30}" y1="${apex.y}" x2="${leftEnd.x - 20}" y2="${apex.y}" stroke="#8b9cb3" stroke-width="1"/>
      <text x="${leftEnd.x - 35}" y="${(GROUND_Y + apex.y) / 2 + 4}" fill="#8b9cb3" font-size="12" text-anchor="end" font-family="system-ui">${height.toFixed(1)} ft</text>
    `;
    els.archGroup.appendChild(heightLine);

    // Render base angle arcs on both ends
    const arcRadius = 40;  // pixels

    // Left side angle arc
    const leftAngleGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    // Draw arc from horizontal to the tangent angle
    const leftArcEndX = leftEnd.x + arcRadius * Math.cos(-theta);  // Note: SVG Y is inverted
    const leftArcEndY = leftEnd.y - arcRadius * Math.sin(theta);
    const leftArcPath = `M ${leftEnd.x + arcRadius} ${leftEnd.y} A ${arcRadius} ${arcRadius} 0 0 0 ${leftArcEndX} ${leftArcEndY}`;

    leftAngleGroup.innerHTML = `
      <path d="${leftArcPath}" fill="none" stroke="#fbbf24" stroke-width="2"/>
      <line x1="${leftEnd.x}" y1="${leftEnd.y}" x2="${leftEnd.x + arcRadius + 10}" y2="${leftEnd.y}" stroke="#fbbf24" stroke-width="1" stroke-dasharray="4,2"/>
      <text x="${leftEnd.x + arcRadius + 5}" y="${leftEnd.y - 15}" fill="#fbbf24" font-size="11" font-family="system-ui">${baseAngleDeg.toFixed(0)}Â°</text>
    `;
    els.archGroup.appendChild(leftAngleGroup);

    // Right side angle arc (mirrored)
    const rightAngleGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    const rightArcEndX = rightEnd.x - arcRadius * Math.cos(-theta);
    const rightArcEndY = rightEnd.y - arcRadius * Math.sin(theta);
    const rightArcPath = `M ${rightEnd.x - arcRadius} ${rightEnd.y} A ${arcRadius} ${arcRadius} 0 0 1 ${rightArcEndX} ${rightArcEndY}`;

    rightAngleGroup.innerHTML = `
      <path d="${rightArcPath}" fill="none" stroke="#fbbf24" stroke-width="2"/>
      <line x1="${rightEnd.x}" y1="${rightEnd.y}" x2="${rightEnd.x - arcRadius - 10}" y2="${rightEnd.y}" stroke="#fbbf24" stroke-width="1" stroke-dasharray="4,2"/>
      <text x="${rightEnd.x - arcRadius - 25}" y="${rightEnd.y - 15}" fill="#fbbf24" font-size="11" font-family="system-ui">${baseAngleDeg.toFixed(0)}Â°</text>
    `;
    els.archGroup.appendChild(rightAngleGroup);
  }

  /**
   * Toggle button handler
   */
  function toggleButton(btn, state) {
    btn.classList.toggle('active', state);
  }

  /**
   * Sync slider and number input
   */
  function syncSliderAndInput(slider, input) {
    slider.addEventListener('input', () => {
      input.value = slider.value;
      render();
    });
    input.addEventListener('input', () => {
      slider.value = input.value;
      render();
    });
  }

  /**
   * Update arch length min/max based on current width
   */
  function updateArchLengthConstraints() {
    const W = parseFloat(els.width.value) || 10;
    const minL = W;
    const maxL = W * 3.0;

    // Update slider and input constraints
    els.archLengthSlider.min = minL;
    els.archLength.min = minL;
    els.archLengthSlider.max = maxL;
    els.archLength.max = maxL;

    // Clamp current value if needed
    const currentL = parseFloat(els.archLength.value);
    if (currentL < minL) {
      els.archLength.value = minL;
      els.archLengthSlider.value = minL;
    } else if (currentL > maxL) {
      els.archLength.value = maxL;
      els.archLengthSlider.value = maxL;
    }

    // Also update straight leg distance constraints
    updateStraightLegConstraints();
  }

  /**
   * Update straight leg distance min/max based on current arch length
   */
  function updateStraightLegConstraints() {
    const L = parseFloat(els.archLength.value) || 16;
    // Max straight leg is 40% of arch length (each side), leaving 20% for curve
    const maxStraightLeg = L * 0.4;

    // Update slider and input constraints
    els.straightLegDistanceSlider.max = maxStraightLeg.toFixed(1);
    els.straightLegDistance.max = maxStraightLeg.toFixed(1);

    // Clamp current value if needed
    const currentDist = parseFloat(els.straightLegDistance.value);
    if (currentDist > maxStraightLeg) {
      els.straightLegDistance.value = maxStraightLeg.toFixed(1);
      els.straightLegDistanceSlider.value = maxStraightLeg.toFixed(1);
    }
  }

  /**
   * Initialize event listeners
   */
  function init() {
    // Sync sliders with number inputs
    syncSliderAndInput(els.widthSlider, els.width);
    syncSliderAndInput(els.archLengthSlider, els.archLength);
    syncSliderAndInput(els.baseAngleSlider, els.baseAngle);
    syncSliderAndInput(els.straightLegDistanceSlider, els.straightLegDistance);

    // Update arch length constraints when width changes
    els.widthSlider.addEventListener('input', updateArchLengthConstraints);
    els.width.addEventListener('input', updateArchLengthConstraints);
    // Update straight leg constraints when arch length changes
    els.archLengthSlider.addEventListener('input', updateStraightLegConstraints);
    els.archLength.addEventListener('input', updateStraightLegConstraints);
    // Initialize constraints on load
    updateArchLengthConstraints();

    // Auto angle toggle - disable/enable angle slider
    els.autoAngle.addEventListener('change', () => {
      els.baseAngle.disabled = els.autoAngle.checked;
      els.baseAngleSlider.disabled = els.autoAngle.checked;
      render();
    });
    // Initialize disabled state
    els.baseAngle.disabled = els.autoAngle.checked;
    els.baseAngleSlider.disabled = els.autoAngle.checked;

    // Other input listeners
    const inputs = [
      els.stickLength, els.cutStrategy,
      els.ledLength, els.ledCount
    ];

    inputs.forEach(el => {
      el.addEventListener('input', render);
    });

    // Viz control buttons
    els.btnHeatmap.addEventListener('click', () => {
      showHeatmap = !showHeatmap;
      toggleButton(els.btnHeatmap, showHeatmap);
      render();
    });

    els.btnLeds.addEventListener('click', () => {
      showLeds = !showLeds;
      toggleButton(els.btnLeds, showLeds);
      render();
    });

    els.btnJoins.addEventListener('click', () => {
      showJoins = !showJoins;
      toggleButton(els.btnJoins, showJoins);
      render();
    });

    // Blink mode
    els.blinkMode.addEventListener('change', () => {
      if (els.blinkMode.checked) {
        blinkInterval = setInterval(() => {
          blinkState = !blinkState;
          if (showLeds) render();
        }, 500);
      } else {
        clearInterval(blinkInterval);
        blinkState = true;
        if (showLeds) render();
      }
    });

    // Initial render
    render();
  }

  init();
})();
</script>
</body>
</html>
